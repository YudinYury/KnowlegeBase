# Backend developer checklist (все по ООП, подчернутые в приоритете)

****************************************************************************
## Stage 1, part 1 
## ООП
Вопросы в этом разделе:
  * [Статическое поле или метод.](#Статическое-поле-или-метод.)
  * Инкапсуляция; модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер).
  * Наследование, Абстрактный класс.
  * Ассоциация, Агрегация, Композиция, разница между ними.
  * Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, при проектировании. (привести пример сравнения)
  * Основное назначение интерфейсов. Полиморфизм подтипов.
****************************************************************************

### Объект 
**Объект** — это **именованная сущность**, одновременно содержащая данные(свойства) и поведения(методы).
Слово «одновременно» в данном случае определяет ключевую разницу между ООП и 
другими методологиями программирования. Например, при процедурном программировании 
код размещается в полностью отдельных функциях или процедурах.

**КЛАСС** - это шаблон, предназначенный для создания объектов.
Класс - это именованная сущность из предметной области, возможно, имеющая 
предка (суперкласс), определенная как набор полей и методов.

В JavaScript классы можно организовать по-разному. Говорят, что класс User написан 
в «функциональном» стиле. Далее мы также увидим «прототипный» стиль.

****************************************************************************
### Статическое поле или метод.
https://learn.javascript.ru/static-properties-and-methods
https://code-examples.net/ru/q/176e8f

СТАТИЧЕСКОЕ ПОЛЕ хранит данные, специфичные не для одного объекта, а для всего класса  целиком. Как правило это константы.

`    private static instance: Config;`


СТАТИЧЕСКИЙ МЕТОД: 
  * не использует состояние объекта и использует свойства, передаваемые в параметрах.
  * Статический метод также можно использовать для функций, которые вообще не требуют наличия объекта. Например, просто форматируем передаваемую дату.
  * Статический метод определяется ключевым словом static.

`  static staticMethod() { return 'Вызван статический метод'; }`

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static

`class StaticMethodCall {
  static staticMethod() {
    return 'Вызван статический метод';
  }
  static anotherStaticMethod() {
    return StaticMethodCall.staticMethod() + ' из другого статического метода';
  }
}`
`StaticMethodCall.staticMethod();  //  'Вызван статический метод'`

`StaticMethodCall.anotherStaticMethod();  //  'Вызван статический метод из другого статического метода'`

Статические методы недоступны напрямую, используя ключевое слово this из нестатических методов. 
Вам нужно вызвать их с помощью имени класса: CLASSNAME.STATIC_METHOD_NAME() или вызовом 
метода как свойства конструктора: this.constructor.STATIC_METHOD_NAME().

class StaticMethodCall {
  constructor() {
    console.log(StaticMethodCall.staticMethod()); 
    // 'вызван статический метод.' 

    console.log(this.constructor.staticMethod()); 
    // 'вызван статический метод.' 
  }

  static staticMethod() {
    return 'вызван статический метод.';
  }
}

class Triple {
  static triple(n) {
    if (n === undefined) {
      n = 1;
    }
    return n * 3;
  }
}

class BiggerTriple extends Triple {
  static triple(n) {
    return super.triple(n) * super.triple(n);
  }
}

console.log(BiggerTriple.triple(3));
// 81 (не затрагивается экземпляром родителя)

console.log(tp.triple());
// Выведет сообщение, что "tripple" не является
// функцией ('tp.tripple is not a function').


В ECMAScript 6 вы можете создавать статические функции, используя ключевое слово static :
class Foo {
  static bar() {return 'I am static.'}
}

//'bar' is a property of the class
Foo.bar() // returns 'I am static.'

//'bar' is not a property of instances of the class
var foo = new Foo()
foo.bar() //-> throws TypeError


`class MyClass {
    constructor() {
        this._privateVariable = "Private variable";  // Private variable 
        this.publicVariable = "Public variable";  // Public variable 
    }
    get privateVariable() {
        return this._privateVariable;
    };
    set privateVariable(val) {
        this._privateVariable = (val < 0) ? 0 : val;
    };
}`


****************************************************************************
### ИНКАПСУЛЯЦИЯ; 
модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер).
*
Зачем ? Как применять ?  
Зачем нам надо связывать данные и методы внутри класса ? Кроме закрытия от пользователя.

**ИНКАПСУЛЯЦИЯ** - это Объединение атрибутов и методы в одной сущности/классе и скрытие 
от пользователя класса части свойств и методов, а также способов реализации 
функциональности класса.
При проектировании класса определяем что в классе должно быть видно, а что — нет. 
При хорошем объектно-ориентированном проектировании объект должен показывать только интерфейсы, необходимые другим объектам для взаимодействия с ним. 
Детали, не относящиеся к использованию объекта, должны быть скрыты от всех других 
объектов.

**ИНКАПСУЛЯЦИЯ** обеспечивает модульность (все в одном месте)  и облегчает переиспользование (наследование и композиция), сопровождение и рефакторинг.

ИНКАПСУЛЯЦИЯ позволяет нам управлять доступом к данным в объекте. 
Клиентский код видит только интерфейс (публичные методы), а разработчики могут изменить реализацию не затронув клиентский код.

Для того, чтобы скрытие данных произошло, все атрибуты должны быть объявлены как 
private. Поэтому атрибуты никогда не являются частью интерфейсов. Частью 
интерфейсов классов могут быть только открытые методы. Объявление атрибута как public нарушает концепцию скрытия данных.

* public — доступ к типу или члену возможен из любого другого кода в той же
сборке или иной сборке, которая на него ссылается - у других объектов будет к нему 
прямой доступ;
* private — доступ к типу или члену возможен только из кода в том же классе или
структуре;
* protected — доступ к типу или члену возможен только из кода в том же классе
или структуре или в производном классе;

private
Когда тип данных или метод определен как private, только код этого объекта
сможет получить к нему доступ. 

public class IntSquare {
// закрытый атрибут
private int squareValue;
// открытый интерфейс
public int getSquare (int value) {
  SquareValue = calculateSquare(value);
  return squareValue;
}
// закрытая реализация
private int calculateSquare (int value) {
  return value*value;
  }
}
Следует отметить, что единственной частью класса, доступной для пользовате-
лей, является открытый метод getSquare , который относится к интерфейсу. 
Реализация алгоритма вычисления квадратов чисел заключена в закрытом методе
calculateSquare. Обратите также внимание на то, что атрибут SquareValue 
является private.
объект показывает только интерфейсы, необходимые
пользователям для взаимодействия с ним, а детали, не относящиеся к использова-
нию объекта, скрыты от других объектов.

protected

Ассоциация, Агрегация и Композиция НЕ позволяют обращаться к методам protected

#### ГЕТТЕРЫ И СЕТТЕРЫ
Концепция геттеров и сеттеров поддерживает концепцию скрытия данных. Поскольку другие объекты 
не должны напрямую манипулировать данными, содержащимися в одном из объектов, геттеры и сеттеры 
обеспечивают управляемый доступ к данным объекта. Геттеры и сеттеры иногда называют методами доступа и методами-модификаторами соответственно.
Геттеры и сеттеры в действительности являются свойствами атрибутов — например, свойство get атрибута с именем Name.

Private string strName;
public String Name {
  get {
  return this.strName;
  }
  set {
  if (value == null) return;
  this.strName = value;
  }
}


Сообщения — это механизм коммуникаций между объектами. Например, когда
объект А вызывает метод объекта В, объект А отправляет сообщение объекту В.
Ответ объекта В определяется его возвращаемым значением. Только открытые,
а не закрытые методы объекта могут вызываться другим объектом.

Во многих ситуациях будут попадаться методы, которые также должны быть
скрыты и, таким образом, не являться частью интерфейса. Это прозволит 
разрабочику заменить алгоритм (возможно, потому, что новый алгоритм оказался 
более эффективным), что не повлияет при этом на пользователей разработанных 
классов/интерфейсов.

ПОДПИСИ: ИНТЕРФЕЙСЫ В СОПОСТАВЛЕНИИ С ИНТЕРФЕЙСАМИ
Важно отметить, что существуют интерфейсы как для классов, так и для методов, 
поэтому не путайте их. Интерфейсы классов — это открытые методы. Их вызов 
осуществляется при использовании их подписи, которая главным образом состоит 
из имени метода и списка его параметров.


****************************************************************************
### Наследование, Абстрактный класс.
*
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/extends

#### НАСЛЕДОВАНИЕ - получение по наследству атрибутов и поведений от родительского класса/классов.

Наследование: класс может унаследовать — использовать по умолчанию — поля и методы своего предка. 
Класс может наследовать от другого класса и использовать атрибуты и методы своего предка. 

НАСЛЕДОВАНИЕ подразумевает получение по наследству атрибутов и поведений от родительского класса/классов.
При этом имеет место настоящее отношение «родительский класс/дочерний класс». Дочерний класс (или подкласс) наследует напрямую от родительского класса (или суперкласса).

Наследование характеризуется отношением «является экземпляром».

Ключевое слово extends используется в объявлении класса или в выражениях класса 
для создания дочернего класса.

class Square extends Polygon {
  constructor(length) {
    super(length, length);
    this.name = 'Square';
  }

Метод Object.create() создаёт новый объект с указанными объектом прототипа и свойствами.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create

Класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (обычно — Object), возможно, неявного. Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию.
Берем класс, который нас почти устраивает и через переопределение части методов 
(функциональности) или через композицию создаем нужного нам потомка.
Не копи-пастим больших кусков кода.

Наследование в JS построено на прототипах.
При структурном проектировании повторное использование кода допускается в известной мере: 
вы можете написать процедуру, а затем применять ее столько раз, сколько пожелаете.
Однако объектно-ориентированное проектирование делает важный шаг вперед,
позволяя вам определять отношения между классами, которые не только облегча-
ют повторное использование кода, но и способствуют созданию лучшей общей
конструкции путем упорядочения и учета общности разнообразных классов.
Основное средство обеспечения такой функциональности — наследование.
Наследование позволяет классу наследовать атрибуты и методы другого класса.
Это дает возможность создавать абсолютно новые классы путем абстрагирования
общих атрибутов и поведений.
Суперкласс, или родительский класс (иногда называемый базовым), содержит все
атрибуты и поведения, общие для классов, которые наследуют от него.
Подкласс, или дочерний класс (иногда называемый производным), представ-
ляет собой расширение суперкласса.

#### Абстрагирование
Абстрагирование означает выделение значимой информации и исключение из рассмотрения 
незначимой (для данного проекта):
  - важна возможность переиспользования в будущем
  - абстракции помогают в работе со сложным
  - Позволяет представить сложную реальность в виде упрощённой модели


#### АБСТРАКТНЫЙ КЛАСС — это класс, у которого не реализован один или больше методов (абстрактные методы). 
Если подкласс наследует абстрактный метод от суперкласса, то он должен обеспечивать конкретную реализацию этого метода, поскольку иначе он сам будет абстрактным классом.

Абстрактный базовый класс описывает некоторое семейство типов, но помимо декларации операций может содержать реализации по умолчанию (виртуальные методы) и фиксированные операции (невиртуальные методы).

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода (переопределять все методы, а не наследовать уже готовые).

В некоторых языках (С++) специального ключевого слова для обозначения интерфейсов нет.
Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.

Конкретный класс описывает некоторое семейство типов, которое готово для использования клиентами. Такой класс не может содержать декларации операций и все его операции должны быть либо фиксированными (невиртуальные методы) или содержать реализацию по умолчанию (виртуальные методы). 
Есть еще один подвид конкретных классов – запечатанный (**sealed**) класс – это разновидность конкретного класса отнаследоваться от которого невозможно, а значит он может содержать лишь конкретные операции.

Допустим, у вас есть абстрактный класс Shape. Он является абстрактным потому, что 
у него есть абстрактный метод draw() и нельзя создать экземпляр класса Shape.



В UML-диаграмме
знак плюса ( + ) обозначает public , а знак минуса ( – ) указывает на private
знак решетки ( # ) обозначает Protected

Под абстрагированием мы подразумеваем изоляцию непереносимого кода
в его собственном классе или по крайней мере в его собственном методе (который
может быть переопределен). Например, если вы пишете код для доступа к после-
довательному порту определенного аппаратного обеспечения, то вам следует создать
класс-обертку для работы с ним. Ваш класс затем должен будет отправить сообще-
ние классу-обертке для получения информации и услуг, которые ему нужны.

Object.setPrototypeOf()
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf



****************************************************************************
### Ассоциация, Агрегация, Композиция, разница между ними.
*
Пояснения
http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html
https://habr.com/post/150041/
https://habr.com/post/354046/

Ассоциация, Агрегация и Композиция НЕ позволяют обращаться к методам protected.

#### АССОЦИАЦИЯ (association) 
означает, что два класса как-то связаны между собой, 
и мы пока не знаем точно, в чем эта связь выражена и собираемся уточнить ее в 
будущем. Обычно это отношение используется на ранних этапах дизайна, чтобы 
показать, что зависимость между классами существует, и двигаться дальше.

АССОЦИАЦИЯ означает отношение между классами объектов, которое позволяет одному 
экземпляру объекта вызвать другого, чтобы выполнить действие от его имени. 
Это структурное отношение, поскольку определяет связь между объектами одного 
рода и объектами другого рода и не моделирует поведение.

Ассоциация – это когда один класс включает в себя другой класс в качестве одного из 
полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. Вполне 
естественно, что он не будет являться наследником двигателя (хотя такая архитектура 
тоже возможна в некоторых ситуациях). 

#### АГРЕГАЦИЯ (aggregation)
АГРЕГАЦИЯ подразумевают методику создания нового класса из уже существующих классов 
путём их включения в свой состав. 
Составная часть передается через параметры конструктора. 
Об агрегировании также часто говорят как об «отношении принадлежности» по принципу 
«у машины есть корпус,  колёса и двигатель».
Пожалуй, наиболее интуитивно понятной формой композиции является агрегация.
Агрегация означает, что сложный объект состоит из других объектов.

class Professor;

class Department
{
  private:
    Professor* members[5];  // Aggregation, т.к. нет оператора delete 
};
class Ehe // Пример агрегации
{
private:
    Person& _partner1; // Enthaltener Teil.  // Aggregation
    Person& _partner2; // Enthaltener Teil.  // Aggregation
 
public:
    // Конструктор
    Ehe (Person& partner1, Person& partner2)
        : _partner1(partner1), _partner2(partner2)
    { }
};

#### КОМПОЗИЦИЯ (composition)
Композиция (агрегирование по значению) — более строгий вариант агрегирования, когда 
включаемый объект может существовать только как часть контейнера. 
Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.
Композиция подразумевает создание объектов с использованием других объектов.

Наследование характеризуется отношением «является экземпляром», 
а композиция — отношением «содержит как часть».

Например, автомобиль содержит как часть двигатель. Однако мы не можем сказать, что двигатель является экземпляром автомобиля.
Благодаря композиции мы к тому же можем создавать классы, вкладывая одни классы в другие.

Объекты содержат другие объекты. Объекты зачастую формируются или состоят из 
других объектов — это и есть композиция.
Композиция — индикатор использования отношения «содержит как часть». Когда наследование 
не оказывается правильным выбором при проектировании (из-за того, что отношение 
«является экземпляром» не подходит), обычно используется композиция.

Точно так же, как и наследование, композиция обеспечивает механизм для создания объектов. Фактически есть только два способа создания классов из других классов: наследование 
и композиция. Как мы уже видели, наследование позволяет одному классу наследовать от 
другого. Поэтому мы можем абстрагировать атрибуты и поведения для общих классов. 
Например, как собаки, так и кошки относятся к млекопитающим, поскольку собака является экземпляром млекопитающего так же, как и кошка. Благодаря композиции мы к тому же можем 
создавать классы, вкладывая одни классы в другие.
Для отношений композиции мы используем словосочетание «содержит как часть». Автомобиль содержит как часть двигатель. Однако мы не можем сказать, что двигатель является экземпляром автомобиля.

Во-первых, у класса Employee имеется ассоциация с классом Spouse . У работника может 
не быть супруга либо иметься один супруг (по крайней мере, в нашей культуре у работника 
не может быть более одного супруга). Таким образом, кардинальность этой ассоциации 
представлена как 0...1 .
Отношение между Employee и классом Division говорит о том, что каждый работник может быть ассоциирован с одним и только одним отделом. Это отношение представляет простая единица. Индикатор кардинальности выступает как очень важная часть объектной модели.


****************************************************************************
### Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, 
при проектировании. (привести пример сравнения)
*
https://habr.com/post/177447/

Как наследование, так и композиция представляют собой механизмы повторного использования.
Повторное использование объектов - главная причина существования наследования и композиции.

НАСЛЕДОВАНИЕ: класс может унаследовать — использовать по умолчанию — поля и методы своего предка. 
Класс может наследовать от другого класса и использовать атрибуты и методы своего предка. 

НАСЛЕДОВАНИЕ подразумевает получение по наследству атрибутов и поведений от родительского класса/классов.
При этом имеет место отношение «родительский класс/дочерний класс» - отношением «является экземпляром». Дочерний класс (или подкласс) наследует напрямую от родительского класса (или суперкласса).

КОМПОЗИЦИЯ
Композиция подразумевает использование других классов для создания более сложных классов, то есть для осуществления своего рода сборки. При этом нет никаких отношений «родительский класс/дочерний класс». 
Благодаря композиции мы к тому же можем создавать классы, вкладывая одни классы в другие.

#### ПРЕИМУЩЕСТВА композиции перед наследованием:
1. Нет конфликта имён, возможного при наследовании.
2. Возможность смены агрегируемого объекта в runtime.
3. Полная замена агрегируемого объекта в классах, производных от класса, включающего агрегируемый объект.

В последних двух случаях очень желательно, чтобы сменяемые агрегируемые объекты имели общий интерфейс. А в третьем – чтобы метод, возвращающий такой объект, был виртуальным.

#### минусы композиции:
1. Итак, если нам необходима возможность смены поведения извне, то композиция, по сравнению с наследованием, имеет принципиально другой тип отношений между объектом поведения и объектом, его использующим. Если при наследовании от абстрактного поведения мы имеем отношение 1:1, то при агрегации и возможности установки поведения извне мы получаем отношение 1:many. Т.е. один и тот же объект поведения может использоваться несколькими объектами-владельцами. Это порождает проблемы с общим для нескольких таких объектов-владельцев состоянием поведения.

2. Агрегация (и это, пожалуй, главный нюанс) отличается от наследования в первую очередь тем, что агрегируемый объект не является объектом-владельцем и не содержит информации о нём. Нередки ситуации, когда коду, взаимодействующему с поведением, необходим и сам объект-владелец (например, для получения информации о том, какими ещё поведениями он обладает).

В таком случае, нам придётся или передавать в такой код нетипизированный объект (как object или void*), или создавать дополнительный интерфейс для объекта-владельца (некий IBehaviorOwner), или хранить в поведении циклическую ссылку на объект-владелец. Понятно, что каждый из этих вариантов имеет свои минусы и ещё больше усложняет код. Более того, различные типы поведений могут зависеть друг от друга (и в это вполне допустимо, особенно если они находятся в некоем закрытом самодостаточном модуле).

3. Ну и последний минус — это конечно же производительность. Если объектов-владельцев достаточно много, то создание и уничтожение вместо одного объекта двух или более может не остаться незамеченным.

#### Как не надо наследовать. Пример 1

class Stack extends ArrayList {
    public void push(Object value) { … }
    public Object pop() { … }
}

Казалось бы, класс Stack, все хорошо. Но посмотрите внимательно на его интерфейс. Что должно быть в классе с именем Stack? Методы push() и pop(), что же еще. А у нас? У нас есть get(), set(), add(), remove(), clear() и еще куча барахла, доставшегося от ArrayList, которое стеку ну вообще не нужно.

Можно было бы переопределить все нежелательные методы, а некоторые (например, clear()) даже и адаптировать под наши нужды, но не многовато ли работы из-за одной ошибки в дизайне? На самом деле трех: одной смысловой, одной механической и одной комбинированной:


Утверждение "Stack это ArrayList" ложно. Stack не является подтипом ArrayList. Задача стека — обеспечить выполнение правила LIFO (последним пришел, первым ушел), которое легко удовлетворяется интерфейсом push/pop, но никак не соблюдается интерфейсом ArrayList.
Механически наследование от ArrayList нарушает инкапсуляцию. Клиентскому коду не должно быть известно, что мы решили использовать ArrayList для хранения элементов стека.
Ну и наконец, реализуя стек через ArrayList мы смешиваем две разные предметные области: ArrayList — это коллекция с произвольным доступом, а стек — это понятие из мира очередей, со строго ограниченным (а не произвольным)8 доступом.

Последний пункт — незначительная на первый взгляд, но важная вещь. Посмотрим на нее пристальнее.



****************************************************************************
### Основное назначение интерфейсов. Полиморфизм подтипов. 
*
https://habr.com/post/314258/

ИНТЕРФЕЙСЫ классов — это открытые методы. Их вызов осуществляется при использовании их подписи, которая главным образом состоит из имени метода и списка его параметров.

Должным образом сконструированные классы состоят из двух частей — интерфейса и реализации.
интерфейс включает синтаксис для вызова методов и возврата значений. Если интерфейс не претерпит
изменений, то пользователям будет все равно, изменится ли реализация.

ИНТЕРФЕЙС определяет основные средства коммуникации между объектами. При проектировании любого класса предусматриваются интер фейсы для надлежащего создания экземпляров и эксплуатации объектов. Любое поведение, которое обеспечивается объектом, должно вызываться через сообщение, отправляемое с использованием одного из предоставленных интерфейсов. В случае с интерфейсом должно предусматриваться полное описание того, как пользовате-
ли соответствующего класса будут взаимодействовать с этим классом. В большин-
стве объектно-ориентированных языков программирования методы, являющиеся
частью интерфейсов, определяются как public.

Если интерфейс спроектирован надлежащим образом, то изменения в реализации не должны требовать
внесения изменений в пользовательский код. Помните, что интерфейс включает синтаксис для вызова методов и возврата значений.

Интерфейс, в сущности, будет представлять собой интерфейс программирования
приложений (API — Application Programming Interface), который станут ис-
пользовать программисты. Соответствующие методы в действительности будут
обертками, в которых окажется заключена функциональность (, обеспечиваемая
системой баз данных).

Для каждого из приведенных ранее требований нам необходим метод, обеспе-
чивающий желаемую функциональность. Теперь нам нужно задать несколько
вопросов.
- Чтобы эффективно использовать этот класс, нужно ли вам, как программисту,
еще что-нибудь знать о нем?
- Нужно ли вам знать о том, как внутренний код базы данных открывает ее?
- Требуется ли вам знать о том, как внутренний код базы данных физически вы-
бирает определенную запись?
- Нужно ли вам знать о том, как внутренний код базы определяет то, остались ли
еще записи?
Ответом на все эти вопросы будет звучное «нет»! Вам не нужно знать что-либо
из этой информации. Вам важно лишь получить соответствующие возвращаемые
значения, а также то, что операции выполняются корректно.

Смысл ПОЛИМОРФИЗМА заключается в том, что вы можете отправлять сообщения разным объектам, 
которые будут отвечать на них в соответствии со своими объектными типами.
ПОЛИМОРФИЗМ Означает, что схожие объекты способны по-разному отвечать
на одно и то же сообщение. Например, у вас может быть система с множеством
фигур. Однако круг, квадрат и звезда рисуются по-разному. Используя полиморфизм,
вы можете отправить одно и то же сообщение (например, Draw ) объектам, на
каждый из которых возлагается обязанность по рисованию соответствующей
ему фигуры.

Этот подход направлен на обеспечение стандартизации определенного интер-
фейса среди классов, а также приложений. Представьте себе приложение из офис-
ного пакета, которое позволяет обрабатывать текст, и приложение для работы
с электронными таблицами. Предположим, что они оба включают класс с именем
Office , который содержит интерфейс с именем print() . Этот print() необходим всем
классам, являющимся частью офисного пакета. Любопытно, но несмотря на то, что
текстовый процессор и табличная программа вызывают интерфейс print() , они
делают разные вещи: один выводит текстовый документ, а другая — документ
с электронными таблицами.

ПОЛИМОРФИЗМ – расширение принципа наследования в ООП, реализуемое в JavaScript 
с помощью оператора prototype. Полиморфизм – это когда подкласс класса может 
вызвать ту же самую обобщенную унаследованную функцию в своем собственном контексте.

ПОЛИМОРФИЗМ Означает, что схожие объекты способны по-разному отвечать на одно и 
то же сообщение. Например, у вас может быть система с множеством фигур. Однако 
круг, квадрат и звезда рисуются по-разному. Используя полиморфизм, вы можете 
отправить одно и то же сообщение (например, Draw ) объектам, на каждый из 
которых возлагается обязанность по рисованию соответствующей ему фигуры.

#### ПОЛИМОРФИЗМ ПОДТИПОВ.
Полиморфизм подтипов заключается в том, что вызывающий код использует объект, 
опираясь только на его интерфейс (контракт), не зная при этом фактического типа. 
Такой подход позволяет подтипам реализовывать свое поведение и т.о. изменять 
поведение программы без перекомпиляции кода-клиента.
Например, это дает возможность при статической типизации указывать тип родительского 
класса для единообразной работы с массивом, стостоящим из дочерних (классов) типов. 


